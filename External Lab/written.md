# Homework 1 Written Solutions

## 1. What was your design process for the PEG grammar? Did you make any decisions that made implementing the Visitor class more difficult? (2+ sentences)

The design process for the PEG grammar started by breaking down the MatLang specification into its core components: statements (like `let`, `print`, `def`, `return`), expressions (literals, variables, binary operations, function calls), and types. Rules were created hierarchicelly, defining expressions first (handling operator precedence with separate `add` and `mul` rules, and left-associativity using repetition) and then incorporating them into statements and function definitions. Handling components like function parameters `params?` and return types `("->" ws type)?` required careful use of PEG operators.

Initially, distinguishing between vector and matrix literals in the grammar (`vector` vs `matrix` rules) and creating separate AST nodes (`VectorLiteral`) seemed logical but later caused A LOT of difficulties. The `test_ast.py` comparisons revealed the expected AST used `MatrixLiteral` for vectors, requiring changes to the `visit_vector` method to conform, making the original grammar distinction less directly mapped to the final AST structure. Significant AI assistance was used to debug the visitor logic, especially for correctly parsing nested structures like function parameters and handling the specific output format required by the tests.

## 2. Did you notice any instances where the semantics of the language were ambiguous? How did your interpreter handle those ambiguities? (1+ sentences)

The main ambiguity arose from the difference between the language specification, the provided test examples (`sample_asts.pickle`), and a strictly typed implementation. Specifically:
1.  **Vector Representation:** The spec describes vectors as `Mat(1, n)`, but the initial grammar and visitor created a distinct `VectorLiteral` AST node. The `sample_asts.pickle` file expected vectors to be represented as `MatrixLiteral` nodes with a single row. The parser's `visit_vector` method was ultimately modified to produce `MatrixLiteral` nodes to pass the tests, aligning the interpreter's input AST with the test expectations.
2.  **Polymorphic Dimensions:** The specification introduces polymorphic dimensions like `a` in `Mat(a, a)`. While the `typ.py` classes initially used a distinct `TypeVarDim('a')` object, the `sample_asts.pickle` file represented these directly as strings (`'a'`) within the `MatrixType`'s shape tuple. The parser's `visit_type` method was adjusted to store these as strings to match the tests, and the type checker (`typ.py`) was subsequently updated to handle shape tuples containing either `ConcreteDim` objects or strings.

The interpreter (`AST.py`) inherently handled these by working with the final AST structure produced by the parser; its logic primarily depended on the *structure* (e.g., `MatrixLiteral.values`) rather than the specific type names used for dimensions within the `MatrixType` annotations (which are mainly used by the type checker).

## 3. Did you do any of the bonus sections?

No, the bonus sections (like full type inference using `_`) were not attempted. The focus was on implementing and debugging the core requirements of the parser, type checker, and interpreter, including the specified polymorphism handling.

## Feedback (at least 1 sentence each)

### What did you enjoy about this assignment

As someone less experienced, I acknowledge this was quite challenging and relied heavily on AI assistance for debugging and formatting corrections. However, it was enjoyable to work at a lower level, designing a language from the grammar up through interpretation. Getting the parser (`parse.py`) to correctly handle operator precedence/associativity and build the AST, especially after significant debugging iterations, was particularly rewarding as the concepts started to click. Seeing the whole pipeline finally execute correctly on the examples felt like a good accomplishment.

### What did you not enjoy about this assignment

The assignment felt like it had a very steep learning curve, going from the specification to a fully working implementation ("0-to-1"). Debugging the subtle mismatches between the AST generated by the parser and the structure expected by the `sample_asts.pickle` file was quite difficult and time-consuming, requiring many small adjustments to the visitor methods. Understanding how Parsimonious structures its output for optional rules and repetitions also took significant effort and iteration, often needing AI help to resolve visitor errors.
